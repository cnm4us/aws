<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
    <title>Feed</title>
    <style>
      :root { color-scheme: dark; }
      html, body { height: 100%; }
      body { margin: 0; background: #000; overflow: hidden; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
      .splash { position: fixed; inset: 0; display: grid; place-items: center; background: linear-gradient(180deg, #000, #111); z-index: 10; }
      .splash .btn { color:#fff; background:#0a84ff; border:none; padding:14px 20px; border-radius:12px; font-size: 16px; }
      .rail { position: fixed; inset: 0; overflow-y: auto; overflow-x: hidden; display: block; scroll-snap-type: y mandatory; scroll-behavior: smooth; }
      .slide { position: relative; width: 100vw; height: 100dvh; scroll-snap-align: center; background:#000; }
      .slide .holder { position:absolute; inset:0; }
      video { position:absolute; inset:0; width:100%; height:100%; object-fit: cover; background:#000; }
      .hint { position:absolute; bottom: 12px; right: 12px; color:#fff9; font-size: 12px; }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/hls.js@1"></script>
  </head>
  <body>
    <div class="splash" id="splash">
      <button class="btn" id="start">Tap to start</button>
    </div>
    <div class="rail" id="rail"></div>
    <script>
      const rail = document.getElementById('rail');
      const splash = document.getElementById('splash');
      const startBtn = document.getElementById('start');

      let items = [];
      let currentIndex = 0;
      let unlocking = false;
      // Tracks which slide index each player currently represents: [prevIdx, curIdx, nextIdx]
      let poolMap = [-1, -1, -1];

      // Player pool
      function createPlayer(){
        const v = document.createElement('video');
        v.playsInline = true; v.muted = true; v.preload = 'metadata'; v.controls = false; v.setAttribute('webkit-playsinline','');
        return { video: v, hls: null, url: null, idx: -999 };
      }
      const pool = [createPlayer(), createPlayer(), createPlayer()];

      function attachSource(player, url){
        if (player.url === url) return;
        // detach old
        if (player.hls){ player.hls.detachMedia(); player.hls.destroy(); player.hls = null; }
        player.video.src = '';
        player.url = url;
        if (!url) return;
        if (player.video.canPlayType('application/vnd.apple.mpegurl')){
          player.video.src = url;
        } else if (window.Hls && Hls.isSupported()){
          const hls = new Hls({ capLevelToPlayerSize:true, startLevel:-1, maxBufferLength:15, backBufferLength:0 });
          hls.loadSource(url);
          hls.attachMedia(player.video);
          player.hls = hls;
        } else {
          player.video.src = url;
        }
      }

      function ensureSlides(count){
        while (rail.children.length < count){
          const slide = document.createElement('div'); slide.className='slide';
          const holder = document.createElement('div'); holder.className='holder';
          slide.appendChild(holder);
          const hint = document.createElement('div'); hint.className='hint'; hint.textContent = '';
          slide.appendChild(hint);
          rail.appendChild(slide);
        }
      }

      function mountPlayerToSlide(player, slideIndex){
        const slide = rail.children[slideIndex]; if (!slide) return;
        const holder = slide.querySelector('.holder');
        if (player.video.parentElement !== holder){
          holder.innerHTML = '';
          holder.appendChild(player.video);
        }
        player.idx = slideIndex;
      }

      async function setCurrentPlayback(){
        for (let p=0;p<3;p++){
          const player = pool[p];
          if (player.idx === currentIndex){
            player.video.muted = false; try { await player.video.play(); } catch {}
          } else {
            player.video.muted = true; try { player.video.pause(); } catch {}
          }
        }
      }

      async function mapPool(idx){
        // Determine direction and rotate pool to avoid re-attaching current
        if (idx === currentIndex + 1) {
          // advance forward: prev<-cur, cur<-next, next<-prev
          const oldPrev = pool[0]; pool[0] = pool[1]; pool[1] = pool[2]; pool[2] = oldPrev;
          poolMap = [idx-1, idx, idx+1];
        } else if (idx === currentIndex - 1) {
          // go backward: next<-cur, cur<-prev, prev<-next
          const oldNext = pool[2]; pool[2] = pool[1]; pool[1] = pool[0]; pool[0] = oldNext;
          poolMap = [idx-1, idx, idx+1];
        } else {
          // jump or init: direct map
          poolMap = [idx-1, idx, idx+1];
        }

        currentIndex = idx;
        ensureSlides(Math.min(items.length, idx+3));

        for (let p=0;p<3;p++){
          const targetIdx = poolMap[p];
          const player = pool[p];
          if (targetIdx < 0 || targetIdx >= items.length){ attachSource(player, null); continue; }
          const url = items[targetIdx].url;
          mountPlayerToSlide(player, targetIdx);
          attachSource(player, url);
          // Preload non-current players
          if (p !== 1) { try { await player.video.play(); player.video.pause(); } catch {} }
        }
        await setCurrentPlayback();
      }

      async function fetchPage(cursor){
        const q = new URLSearchParams({ status:'completed', limit:'20' });
        if (cursor) q.set('cursor', String(cursor));
        const res = await fetch('/api/uploads?'+q.toString());
        const data = await res.json();
        return data.map(r => ({ id: r.id, url: r.cdn_master || r.s3_master }));
      }

      function setupObserver(){
        const io = new IntersectionObserver((entries)=>{
          let best = { idx: currentIndex, ratio: 0 };
          for (const e of entries){
            const el = e.target; const idx = Array.prototype.indexOf.call(rail.children, el);
            if (e.intersectionRatio > best.ratio){ best = { idx, ratio: e.intersectionRatio }; }
          }
          if (best.ratio > 0.7 && best.idx !== currentIndex){ mapPool(best.idx); }
          // paginate when near end
          if (rail.children.length - currentIndex < 5) maybeLoadMore();
        }, { root: rail, threshold: [0,0.25,0.5,0.7,0.9,1] });
        Array.from(rail.children).forEach(ch => io.observe(ch));
        return io;
      }

      let lastId = undefined; let loadingMore = false; let observer;
      async function maybeLoadMore(){
        if (loadingMore) return; loadingMore = true;
        const cursor = lastId;
        const page = await fetchPage(cursor);
        if (page.length){
          items = items.concat(page);
          lastId = items[items.length-1].id;
          const prevLen = rail.children.length;
          ensureSlides(items.length);
          // observe new slides
          if (observer){ for (let i=prevLen;i<rail.children.length;i++){ observer.observe(rail.children[i]); } }
        }
        loadingMore = false;
      }

      async function init(){
        // initial page
        items = await fetchPage();
        if (!items.length){ splash.querySelector('.btn').textContent = 'No videos yet'; return; }
        lastId = items[items.length-1].id;
        ensureSlides(items.length);
        observer = setupObserver();
        await mapPool(0);
      }

      function unlockGesture(){
        if (unlocking) return; unlocking = true; splash.style.display='none';
        // Synchronously request play on all players (muted) to unlock
        for (const p of pool){ try { p.video.muted = true; const pr = p.video.play(); if (pr && pr.catch) pr.catch(()=>{}); } catch {} }
        // After a tick, pause neighbors and play current unmuted
        setTimeout(()=>{
          const cur = pool.find(p => p.idx === currentIndex) || pool[1];
          for (const p of pool){ if (p !== cur) { try { p.video.pause(); } catch{} } }
          if (cur){ try { cur.video.muted = false; cur.video.play().catch(()=>{}); } catch{} }
          // Re-map to enforce state
          mapPool(currentIndex);
        }, 0);
      }

      // If page returns to foreground, ensure current keeps playing
      document.addEventListener('visibilitychange', ()=>{
        if (document.visibilityState === 'visible' && splash.style.display==='none'){
          const cur = pool.find(p => p.idx === currentIndex);
          if (cur){ try { cur.video.play().catch(()=>{}); } catch{} }
        }
      });

      startBtn.addEventListener('click', unlockGesture);
      document.addEventListener('touchend', (e)=>{ if (splash.style.display!=='none') unlockGesture(); }, { passive:true });

      init();
    </script>
  </body>
  </html>
