<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
    <title>Feed</title>
    <style>
      :root { color-scheme: dark; }
      html, body { height: 100%; }
      body { margin: 0; background: #000; overflow: hidden; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
      .splash { position: fixed; inset: 0; display: grid; place-items: center; background: linear-gradient(180deg, #000, #111); z-index: 10; }
      .splash .btn { color:#fff; background:#0a84ff; border:none; padding:14px 20px; border-radius:12px; font-size: 16px; }
      .rail { position: fixed; inset: 0; overflow-y: auto; overflow-x: hidden; display: block; scroll-snap-type: y mandatory; overscroll-behavior: contain; scroll-behavior: smooth; }
      .slide { position: relative; width: 100vw; height: 100dvh; scroll-snap-align: start; scroll-snap-stop: always; background:#000; background-size: cover; background-position: center; background-repeat: no-repeat; }
      .slide .holder { position:absolute; inset:0; }
      video { position:absolute; inset:0; width:100%; height:100%; object-fit: cover; background: transparent; opacity: 0; transition: opacity .12s linear; }
      .hint { position:absolute; bottom: 12px; right: 12px; color:#fff9; font-size: 12px; }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/hls.js@1"></script>
  </head>
  <body>
    <div class="splash" id="splash">
      <button class="btn" id="start">Tap to start</button>
    </div>
    <div class="rail" id="rail"></div>
    <script>
      const rail = document.getElementById('rail');
      const splash = document.getElementById('splash');
      const startBtn = document.getElementById('start');

      let items = [];
      let currentIndex = 0;
      let unlocking = false;
      // Tracks which slide index each player currently represents: [prevIdx, curIdx, nextIdx]
      let poolMap = [-1, -1, -1];

      // Player pool
      function createPlayer(){
        const v = document.createElement('video');
        v.playsInline = true; v.muted = true; v.preload = 'auto'; v.controls = false; v.setAttribute('webkit-playsinline','');
        return { video: v, hls: null, url: null, idx: -999, warming: false, warmTimer: null };
      }
      const pool = [createPlayer(), createPlayer(), createPlayer()];

      function attachSource(player, url){
        if (player.url === url) return;
        // detach old
        if (player.hls){ player.hls.detachMedia(); player.hls.destroy(); player.hls = null; }
        player.video.src = '';
        player.url = url;
        if (!url) return;
        if (player.video.canPlayType('application/vnd.apple.mpegurl')){
          player.video.src = url;
        } else if (window.Hls && Hls.isSupported()){
          const hls = new Hls({ capLevelToPlayerSize:true, startLevel:-1, maxBufferLength:30, backBufferLength:10, startFragPrefetch: true });
          hls.loadSource(url);
          hls.attachMedia(player.video);
          player.hls = hls;
        } else {
          player.video.src = url;
        }
      }

      function ensureSlides(count){
        while (rail.children.length < count){
          const slide = document.createElement('div'); slide.className='slide';
          const holder = document.createElement('div'); holder.className='holder';
          slide.appendChild(holder);
          const hint = document.createElement('div'); hint.className='hint'; hint.textContent = '';
          slide.appendChild(hint);
          rail.appendChild(slide);
        }
      }

      function mountPlayerToSlide(player, slideIndex){
        const slide = rail.children[slideIndex]; if (!slide) return;
        const holder = slide.querySelector('.holder');
        if (player.video.parentElement !== holder){
          holder.innerHTML = '';
          holder.appendChild(player.video);
        }
        player.idx = slideIndex;
      }

      async function setCurrentPlayback(options){
        const muteAll = options && options.muteAll;
        for (let p=0;p<3;p++){
          const player = pool[p];
          if (player.idx === currentIndex){
            player.video.muted = !!muteAll; try { await player.video.play(); } catch {}
          } else {
            player.video.muted = true; try { player.video.pause(); } catch {}
          }
        }
      }

      function warmNext(player){
        if (!player || player.warming) return;
        player.warming = true;
        if (player.warmTimer) { clearTimeout(player.warmTimer); player.warmTimer = null; }
        try {
          player.video.muted = true;
          // Play ~1200ms while hidden to accumulate buffer, then pause and reset to start
          const pr = player.video.play();
          if (pr && pr.then) pr.then(()=>{
            player.warmTimer = setTimeout(()=>{
              // If this player became current meanwhile, don't pause it
              if (player.idx === currentIndex) { player.warming = false; player.warmTimer = null; return; }
              try { player.video.pause(); player.video.currentTime = 0.01; } catch{}
              player.warming = false; player.warmTimer = null;
            }, 1200);
          }).catch(()=>{ player.warming = false; });
        } catch { player.warming = false; }
      }

      async function mapPool(idx){
        // Determine direction and rotate pool to avoid re-attaching current
        if (idx === currentIndex + 1) {
          // advance forward: prev<-cur, cur<-next, next<-prev
          const oldPrev = pool[0]; pool[0] = pool[1]; pool[1] = pool[2]; pool[2] = oldPrev;
          poolMap = [idx-1, idx, idx+1];
        } else if (idx === currentIndex - 1) {
          // go backward: next<-cur, cur<-prev, prev<-next
          const oldNext = pool[2]; pool[2] = pool[1]; pool[1] = pool[0]; pool[0] = oldNext;
          poolMap = [idx-1, idx, idx+1];
        } else {
          // jump or init: direct map
          poolMap = [idx-1, idx, idx+1];
        }

        currentIndex = idx;
        ensureSlides(Math.min(items.length, idx+3));

        for (let p=0;p<3;p++){
          const targetIdx = poolMap[p];
          const player = pool[p];
          if (targetIdx < 0 || targetIdx >= items.length){ attachSource(player, null); continue; }
          const url = items[targetIdx].url;
          mountPlayerToSlide(player, targetIdx);
          attachSource(player, url);
          // Set slide background to poster for approach
          const slideNode = rail.children[targetIdx];
          if (slideNode && items[targetIdx].poster) (slideNode).style.backgroundImage = `url('${items[targetIdx].poster}')`;
          // Prewarm NEXT offscreen
          if (p === 2) { warmNext(player); }
          // Keep PREV paused
          if (p === 0) { try { player.video.pause(); } catch {} }
          // Ensure CURRENT video is visible and not subject to warm timers
          // Set baseline opacity: current=1, others=0
          if (p === 1) {
            if (player.warmTimer){ clearTimeout(player.warmTimer); player.warmTimer = null; }
            player.warming = false;
            player.video.style.opacity = '1';
          } else {
            player.video.style.opacity = '0';
          }
        }
        await setCurrentPlayback({ muteAll: splash.style.display !== 'none' });
      }

      async function fetchPage(cursor){
        const q = new URLSearchParams({ status:'completed', limit:'20' });
        if (cursor) q.set('cursor', String(cursor));
        const res = await fetch('/api/uploads?'+q.toString());
        const data = await res.json();
        return data.map(r => ({ id: r.id, url: r.cdn_master || r.s3_master, poster: r.poster_cdn || r.poster_s3 }));
      }

      function setupObserver(){
        const io = new IntersectionObserver((entries)=>{
          let best = { idx: currentIndex, ratio: 0 };
          for (const e of entries){
            const el = e.target; const idx = Array.prototype.indexOf.call(rail.children, el);
            if (e.intersectionRatio > best.ratio){ best = { idx, ratio: e.intersectionRatio }; }
            if (idx === currentIndex + 1){
              if (e.intersectionRatio > 0.5){
                const nextP = pool.find(p => p.idx === idx);
                if (nextP) { warmNext(nextP); /* keep next video fully transparent to avoid dimming poster */ }
              }
            }
          }
          // Switch when slide is ~85% in place for quicker start
          if (best.ratio > 0.85 && best.idx !== currentIndex){ mapPool(best.idx); }
          // paginate when near end
          if (rail.children.length - currentIndex < 5) maybeLoadMore();
        }, { root: rail, threshold: [0,0.25,0.5,0.7,0.85,0.9,1] });
        Array.from(rail.children).forEach(ch => io.observe(ch));
        return io;
      }

      let lastId = undefined; let loadingMore = false; let observer;
      async function maybeLoadMore(){
        if (loadingMore) return; loadingMore = true;
        const cursor = lastId;
        const page = await fetchPage(cursor);
        if (page.length){
          items = items.concat(page);
          lastId = items[items.length-1].id;
          const prevLen = rail.children.length;
          ensureSlides(items.length);
          // observe new slides
          if (observer){ for (let i=prevLen;i<rail.children.length;i++){ observer.observe(rail.children[i]); } }
        }
        loadingMore = false;
      }

      async function init(){
        // initial page
        items = await fetchPage();
        if (!items.length){ splash.querySelector('.btn').textContent = 'No videos yet'; return; }
        lastId = items[items.length-1].id;
        ensureSlides(items.length);
        observer = setupObserver();
        await mapPool(0);
        // Prewarm first video under splash (muted) so audio starts immediately upon unlock
        const cur0 = pool.find(p => p.idx === 0) || pool[1];
        if (cur0){ try { cur0.video.muted = true; await cur0.video.play(); cur0.video.pause(); cur0.video.currentTime = 0.01; } catch{} }
      }

      function unlockGesture(){
        if (unlocking) return; unlocking = true; splash.style.display='none';
        // Synchronously request play on all players (muted) to unlock
        for (const p of pool){ try { p.video.muted = true; const pr = p.video.play(); if (pr && pr.catch) pr.catch(()=>{}); } catch {} }
        // After a tick, pause neighbors and play current unmuted
        setTimeout(()=>{
          const cur = pool.find(p => p.idx === currentIndex) || pool[1];
          for (const p of pool){ if (p !== cur) { try { p.video.pause(); } catch{} } }
          if (cur){ try { cur.video.muted = false; cur.video.play().catch(()=>{}); } catch{} }
          // Re-map to enforce state
          mapPool(currentIndex);
        }, 0);
      }

      // If page returns to foreground, ensure current keeps playing
      document.addEventListener('visibilitychange', ()=>{
        if (document.visibilityState === 'visible' && splash.style.display==='none'){
          const cur = pool.find(p => p.idx === currentIndex);
          if (cur){ try { cur.video.play().catch(()=>{}); } catch{} }
        }
      });

      startBtn.addEventListener('click', unlockGesture);
      document.addEventListener('touchend', (e)=>{ if (splash.style.display!=='none') unlockGesture(); }, { passive:true });

      init();
    </script>
  </body>
  </html>
