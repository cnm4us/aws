<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Upload to S3</title>
    <style>
      body { font-family: system-ui, sans-serif; margin: 2rem; }
      .box { border: 1px solid #ddd; padding: 1rem; border-radius: 8px; max-width: 640px; }
      progress { width: 100%; height: 20px; }
      .row { margin: 0.5rem 0; }
      label { display: block; font-weight: 600; margin-bottom: 0.25rem; }
      input[type=file] { padding: 0.5rem; }
      button { padding: 0.5rem 1rem; }
      .log { white-space: pre-wrap; background: #fafafa; border: 1px dashed #ddd; padding: 0.5rem; margin-top: 1rem; font-family: ui-monospace, monospace; font-size: 0.9rem; }
    </style>
  </head>
  <body>
    <div class="box">
      <h2>Direct Upload to S3</h2>
      <div class="row">
        <label for="file">Choose a video file</label>
        <input id="file" type="file" accept="video/*" />
      </div>
      <div class="row">
        <button id="start">Upload</button>
      </div>
      <div class="row">
        <progress id="prog" value="0" max="100"></progress>
      </div>
      <div id="msg" class="row"></div>
      <div class="log" id="log"></div>
    </div>

    <script>
      const elFile = document.getElementById('file');
      const elStart = document.getElementById('start');
      const elProg = document.getElementById('prog');
      const elMsg = document.getElementById('msg');
      const elLog = document.getElementById('log');

      function log(msg, data) {
        const line = typeof data !== 'undefined' ? `${msg} ${JSON.stringify(data)}` : msg;
        elLog.textContent += `\n${line}`;
      }

      function getCsrfToken() {
        const m = document.cookie.match(/(?:^|;)\s*csrf=([^;]+)/);
        return m ? decodeURIComponent(m[1]) : null;
      }

      async function ensureLoggedIn() {
        try {
          const res = await fetch('/api/me');
          if (!res.ok) throw new Error();
          const data = await res.json();
          if (!data || !data.userId) throw new Error();
          return data;
        } catch {
          elStart.disabled = true;
          elMsg.textContent = 'Please log in first.';
          return null;
        }
      }

      async function probeVideo(file) {
        return new Promise((resolve) => {
          try {
            const url = URL.createObjectURL(file);
            const v = document.createElement('video');
            v.preload = 'metadata';
            v.src = url;
            v.onloadedmetadata = () => {
              const meta = { width: v.videoWidth || null, height: v.videoHeight || null, durationSeconds: v.duration ? Math.round(v.duration) : null };
              URL.revokeObjectURL(url);
              resolve(meta);
            };
            v.onerror = () => resolve({ width: null, height: null, durationSeconds: null });
          } catch { resolve({ width: null, height: null, durationSeconds: null }); }
        });
      }

      elStart.addEventListener('click', async () => {
        const file = elFile.files && elFile.files[0];
        if (!file) { alert('Choose a file first'); return; }
        elProg.value = 0; elMsg.textContent = '';

        try {
          const me = await ensureLoggedIn();
          if (!me) return;
          const meta = await probeVideo(file);
          // 1) Ask server for a presigned POST
          const body = {
            filename: file.name,
            contentType: file.type || 'application/octet-stream',
            sizeBytes: file.size,
            ...meta
          };
          log('sign body', body);
          const headers = { 'Content-Type': 'application/json' };
          const csrf = getCsrfToken();
          if (csrf) headers['x-csrf-token'] = csrf;
          const signRes = await fetch('/api/sign-upload', {
            method: 'POST', headers, body: JSON.stringify(body)
          });
          if (!signRes.ok) throw new Error('Failed to sign upload');
          const { id, post } = await signRes.json();
          log('signed', { id, url: post.url, key: post.fields.key });

          // 2) Build form data for S3
          const formData = new FormData();
          Object.entries(post.fields).forEach(([k, v]) => formData.append(k, v));
          formData.append('file', file);

          // 3) Upload with progress via XHR
          let etag = null;
          await new Promise((resolve, reject) => {
            const xhr = new XMLHttpRequest();
            xhr.open('POST', post.url, true);
            // S3 returns XML on 201; allow parsing
            xhr.responseType = 'document';
            xhr.upload.addEventListener('progress', (e) => {
              if (e.lengthComputable) {
                const pct = Math.round((e.loaded / e.total) * 100);
                elProg.value = pct;
              }
            });
            xhr.onload = () => {
              if (xhr.status >= 200 && xhr.status < 300) {
                try {
                  // Prefer parsed XML if available
                  const xmlDoc = xhr.responseXML || new DOMParser().parseFromString(xhr.responseText || '', 'application/xml');
                  const tag = xmlDoc && xmlDoc.getElementsByTagName('ETag')[0];
                  if (tag && tag.textContent) {
                    etag = tag.textContent.replace(/^\"|\"$/g, '');
                    log('s3 etag', etag);
                  }
                } catch (e) {
                  // ignore parse issues; ETag is optional for our flow
                }
                resolve();
              }
              else reject(new Error(`S3 upload failed: ${xhr.status}`));
            };
            xhr.onerror = () => reject(new Error('Network error uploading to S3'));
            xhr.send(formData);
          });

          // 4) Mark complete on server
          const headersComplete = { 'Content-Type': 'application/json' };
          const csrfComplete = getCsrfToken();
          if (csrfComplete) headersComplete['x-csrf-token'] = csrfComplete;
          const completeRes = await fetch('/api/mark-complete', {
            method: 'POST', headers: headersComplete, body: JSON.stringify({ id, sizeBytes: file.size, etag })
          });
          if (!completeRes.ok) throw new Error('Failed to mark complete');

          elMsg.textContent = 'Upload complete!';
          log('complete', {});
        } catch (err) {
          console.error(err);
          elMsg.textContent = 'Upload failed: ' + err.message;
          log('error', err.message);
        }
      });
    </script>
  </body>
  </html>
